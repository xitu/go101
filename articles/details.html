<h1>Go Details 101</h1>

<div>
<p>
This article will list all kinds of details in Go.
Some of these details are shown in other Go 101 articles,
some are shown in the following sections.
</p>

<ul>
<li>
	<a href="value-part.html#about-value-copy">When copying a value, only the direct part of the value is copied.</a>
</li>
<li>
	<a href="type-system-overview.html#type-definition">Types can be declared within function bodies.</a>
</li>
<li>
	<a href="#import-package-multiple-times">A package can be imported more than once in a source file.</a>
</li>
<li>
	<a href="#force-import-path">The comment <code>// import "x.y.z.mypkg"</code> following <code>package mypkg</code> is meaningful for the standard Go compiler.</a>
</li>
<li>
	<a href="#naa-inf">NaN != NaN, Inf == Inf.</a>
</li>
<li>
	Control flow related details:
	<ul>
	<li>
		<a href="control-flows.html#default-branch-placement">The <code>default</code> branch in <code>switch</code> and <code>select</code> blocks can be put before all case branches, after all case branches, or between case branches.</a>
	</li>
	<li>
		<a href="control-flows-more.html#defer-modify-resutls">Nested deferred function calls can modify return result values of nesting functions.</a>
	</li>
	</ul>
</li>
<li>
	Pointer related details:
	<ul>
	<li>
		<a href="pointer.html#restrictions">For a numeric value pointer <code>p</code>, expression <code>*p++</code> is equivalent to <code>(*p)++</code>. If <code>p</code> is not an numeric value pointer, <code>*p++</code> doesn't compile.</a>
	</li>
	<li>
		<a href="value-conversions-assignments-and-comparisons.html#conversion-rule-underlying-types">Values of two named pointer types can be converted to each other if the base types of the two types are identical. The underlying types of the two pointer types can be different.</a>
	</li>
	<li>
		<a href="#addresses-of-zeor-sized-values">Addresses of different zero-sized value may be equal, or not.</a>
	</li>
	<li>
		<a href="#self-based-pointer-type">The base type of a pointer type may be the pointer type itself.</a>
	</li>
	<li>
		<a href="#pointer-selector-shorthands">A detail about selector shorthands.</a>
	</li>
	</ul>
</li>
<li>
	Container related details:
	<ul>
	<li>
		<a href="container.html#composite-literal-simplification">Sometimes, nested composite Literals can be simplified.</a>
	</li>
	<li>
		<a href="container.html#use-pointer-as-array">In some scenarios, it is ok to use array pointers as arrays.</a>
	</li>
	<li>
		<a href="container.html#element-accessment">Retreiving elements from nil maps will not panic. The result is a zero element value.</a>
	</li>
	<li>
		<a href="container.html#element-addition-deletion">Deleting an entry from a nil map will not panic. It is a no-op.</a>
	</li>
	<li>
		<a href="container.html#element-addition-deletion">The result slice of an <code>append</code> function call may share the underlying array with the original slice, or not.</a>
	</li>
	<li>
		<a href="container.html#subslice">The length of a subslice may be larger than the base slice the subslice is derived from.</a>
	</li>
	<li>
		<a href="container.html#subslice">Deriving a subslice from a nil slice is ok only if all the indexes used in the subslice expression are zero. The result subslice is also a nil slice.</a>
	</li>
	<li>
		<a href="container.html#modify-slice-length-and-capacity">The length and capacity of a slice can be modified seperately.</a>
	</li>
	<li>
		<a href="container.html#value-literals"">The indexes in slice and array compsiste literals must be non-negative integer constants.</a>
	</li>
	<li>
		<a href="array-slice-element-addressability">Elements of unaddressable arrays are also unaddressable, but elements of unaddressable slices are always addressable.</a>
	</li>
	<li>
		<a href="#array-slice-derivable">It is ok to retrieve subslices from unaddressable slices, but not ok from unaddressable arrays. It is ok to take element addresses for unaddressable slices, but not ok for unaddressable arrays.</a>
	</li>
	<li>
		<a href="#nan-as-map-keys">Putting elements with NaN as key to a map is like putting the elements in a black hole.</a>
	</li>
	<li>
		<a href="#constent-map-keys">Constant key values in a container composite literal can't be duplicated.</a>
	</li>
	<li>
		<a href="container.html#iteration">In a <code>for-range</code> loop code block, any iteration variable can be ignored or omitted.</a>
	</li>
	<li>
		<a href="container.html#iteration">In a for-range loop, the iterator variable(s) and the ranged container are all value copies.</a>
	</li>
	<li>
		<a href="container.html#iteration">Ranging over a nil maps or a nil slices is ok, it is a no-op.</a>
	</li>
	<li>
		<a href="container.html#use-pointer-as-array">Range over a nil array pointer is ok if the second iteration variable is ignored or omitted.</a>
	</li>
	<li>
		<a href="container.html#memclr">There is an optimization made by the standard Go compiler to reset container elements as zero values.</a>
	</li>
	<li>
		<a href="#capacity-of-slice-from-string">The capacity of the result slice of a conversion from a string to byte/rune slice may be larger than the length of the result slice.</a>
	</li>
	</ul>
</li>
<li>
	String related details:
	<ul>
	<li>
		<a href="string.html#comparison">The time complexity of comparing two equal strings may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code>.</a>
	</li>
	<li>
		<a href="string.html#use-string-as-byte-slice">If the first argument of a built-in function <code>copy</code> or <code>append</code> call is a byte slice, then the second argument can be a string followed by <code>...</code>.</a>
	</li>
	</ul>
</li>
<li>
	Interface related details:
	<ul>
	<li>
		<a href="interface.html#comparison">Comparing two interface values with the same uncomparable dynamic type causes a panic.</a>
	</li>
	<li>
		<a href="interface.html#type-assertion">Type assertions can be used to convert a value of an interface type to another interface type, even if the form interface type doesn't implemented the latter one.</a>
	</li>
	<li>
		<a href="exceptions.html#behaviors-on-missing-optional-result">Whether or not the second optional result of a type assertion is present will affect the behavior of the type assertion.</a>
	</li>
	<li>
		<a href="#interface-comparison-complexity">For the standard Go compiler, the time complexity of comparing two equal interface values may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code>.</a>
	</li>
	<li>
		<a href="#interface-copy-complexity">About the time complexity of copying a non-nil interface value.</a>
	</li>
	<li>
		<a href="#errors-new-different-returns">Two <code>error</code> values returned by two <code>errors.New</code> with the same argument are not equal.</a>
	</li>
	</ul>
</li>
<li>
	Channel related details:
	<ul>
	<li>
		<a href="channel.html#operations">Receive-only channels can't be closed.</a>
	</li>
	<li>
		<a href="channel.html#simple-rule-summary">Sending a value to a closed channel is viewed as a non-blocking operation, and this operation causes a panic.</a>
	</li>
	</ul>
</li>
<li>
	<a href="#sometimes-parentheses-are-required">Parentheses are required in several rare scenarios to make code compile okay.</a>
</li>
<li>
	<a href="#different-loops">For a slice <code>s</code>, the loop <code>for i = range s {...}</code> is not equivalent to the loop <code>for i = 0; i < len(s); i++ {...}</code>.</a>
</li>
<li>
	<a href="function.html#call-as-expression">A multi-result function call can't mix with other expessions when the call is used as the sources in an assignment or the arguments of another function call.</a>
</li>
<li>
	<a href="#main-entry-function-missing">A program doesn't need a <code>main</code> entry function to run.</a>
</li>
<li>
	<a href="reflection.html#deep-equal">The results of <code>reflect.DeepEqual(x, y)</code> and <code>x == y</code> may be different.</a>
</li>
<li>
	<a href="line-break-rules.html#commas">The extra last <code>,</code> in an item list (such parameter/argument/result lists and element lists in composite literals) never do harm.</a>
</li>
<li>
	<a href="blocks-and-scopes.html#weird-shadowing"><code>nil</code>, <code>iota</code>, <code>true</code>, <code>false</code> and built-in types are not keywords. They are just predeclared identifiers.</a>
</li>
<li>
	<a href="unofficial-faq.html#final-zero-size-field">For the standard compiler, zero-sized fields in a struct may be treated as one-byte-sized value.</a>
</li>
<li>
	<a href="#check-file-existent">We should not use <code>os.IsNotExist(err)</code> instead of <code>err == os.ErrNotExist</code> to check whether or not a file exists.</a>
</li>
<li>
	<a href="#boolean-flag">The <code>flag</code> standard package treats boolean command flags differently than integer and string flags.</a>
</li>
<li>
	<a href="#printf-positional-arguments"><code>[Sp|Fp|P]rintf</code> functions support positional arguments.</a>
</li>
</ul>
</div>

<p class="anchor" id="import-package-multiple-times"></p>
<h3>A package can be imported more than once in a source file</h3>

<div>
<p>
A Go source file can imports the same package multiple times,
but the import names must be different.
These same-pacakge imports reference the same package instance.
</p>

For example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "io"
import inout "io"

func main() {
	fmt.Println(&inout.EOF == &io.EOF)
}
</code></pre>
</div>

<p class="anchor" id="array-slice-element-addressability"></p>
<h3>Elements of unaddressable arrays are also unaddressable, but elements of unaddressable slices are always addressable</h3>

<div>
<p>
The reason is the elements of an array value and the array will be stored
in the same memory block when the array is stored in memory.
But <a href="unofficial-faq.html#slice-elements-always-addressable">the
situation is different for slices</a>.
</p>

An example:

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Container composite literals and map elements are all unaddressable.
	
	// Take container element addresses.
	_ = &[]int{1}[0] // ok
	_ = &[5]int{}[0] // error: cannot take the address of [5]int literal[0]
	_ = &(&[5]int{})[0] // ok
	_ = &(*&[5]int{})[0] // ok
	
	// Modify container element values.
	map[int]int{}[1] = 9
	[]int{1,2,3}[1] = 9
	[3]int{1,2,3}[1] = 9 // error: cannot assign to [3]int literal[1]
	(&[3]int{1,2,3})[1] = 9
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="array-slice-derivable"></p>
<h3>
It is ok to retrieve subslices from unaddressable slices, but not ok from unaddressable arrays.
It is ok to take element addresses for unaddressable slices, but not ok for unaddressable arrays.
</h3>

<div>
<p>
The reason is the same as the last detail.
</p>

An example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Literal values and map elements are unaddressable in Go.
	
	// The following lines fail to compile.
	/*
	_ = [...]int{6, 7, 8, 9}[1:3]  // error: slice of unaddressable value
	_ = &([...]int{6, 7, 8, 9}[0]) // error: cannot take element address
	var ma = map[string][4]int{"abc": {0, 1, 2, 3}}
	_ = ma["abc"][1:3]  // error: slice of unaddressable value
	_ = &(ma["abc"][0]) // error: cannot take element address
	*/
	
	// The following lines compile okay.
	_ = []int{6, 7, 8, 9}[1:3]
	_ = &([]int{6, 7, 8, 9}[0])
	var ms = map[string][]int{"abc": {0, 1, 2, 3}}
	_ = ms["abc"][1:3]
	_ = &(ms["abc"][0])
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="naa-inf"></p>
<h3>NaN != NaN, Inf == Inf</h3>

<div>
This follows IEEE-754 standard and is consistent with most other programming languages:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "math"

func main() {
	var a = math.Sqrt(-1.0)
	fmt.Println(a)      // NaN
	fmt.Println(a == a) // false
	
	var x = 0.0
	var y1, z1 = 1 / x, 2 / x
	var y2, z2 = -1 / x, -2 / x
	fmt.Println(y1, z1, y1 == z1) // +Inf +Inf true
	fmt.Println(y2, z2, y2 == z2) // +Inf +Inf true
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="nan-as-map-keys"></p>
<h3>Putting elements with NaN as key to a map is like putting the elements in a black hole</h3>

<div>
This reason is <code>NaN != NaN</code> (see the above detail).
The elements with <code>NaN</code> as key can only be found out
in a <code>for-range</code> loop.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "math"

func main() {
	var a = math.NaN()
	fmt.Println(a)      // NaN
	
	var m = map[float64]int{}
	m[a] = 123
	v, present := m[a]
	fmt.Println(v, present) // 0 false
	m[a] = 789
	v, present = m[a]
	fmt.Println(v, present) // 0 false
	
	fmt.Println(m) // map[NaN:<nil> NaN:<nil>]
	delete(m, a) // no-op
	fmt.Println(m) // map[NaN:<nil> NaN:<nil>]
	
	for k, v := range m {
		fmt.Println(k, v)
	}
	// the above loop outputs:
	// NaN 123
	// NaN 789
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="interface-comparison-complexity"></p>
<h3>For the standard Go compiler, the time complexity of comparing two equal interface values may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code></h3>

<div>
The time complexity depends on whether or not the direct parts
of the two equal interfaces both reference the undrelying value.
Please read the article <a href="value-part.html#interface-structure">value parts</a> for detail.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	bigarr := [1 << 20]int{}
	
	type I interface{}
	
	// i0, i1 and i2 are three equal interfaces.
	var i0 I = bigarr // the dynamic value of i0 is a copy of bigarr.
	var i1 I = bigarr // the dynamic value of i1 is also a copy of bigarr.
	                  // Note, the dynamic values of i0 and i1 are
	                  // two different copies of bigarr.
	var i2 I = i1 // i2 shares the same dynamic value copy with i1.

	startTime := time.Now()
	_ = i0 == i1
	duration := time.Since(startTime)
	fmt.Println("duration for (i0 == i1):", duration)
	
	startTime = time.Now()
	_ = i1 == i2
	duration = time.Since(startTime)
	fmt.Println("duration for (i1 == i2):", duration)
}
/*
The output (1ms == 1,000,000ns):
duration for (i0 == i1): 1.381337ms
duration for (i1 == i2): 609ns
*/
</code></pre>
<p>
1ms is 1000000ns!
</p>
</div>

<p class="anchor" id="interface-copy-complexity"></p>
<h3>About the time complexity of copying a non-nil interface value</h3>

<!---
https://github.com/golang/go/issues/17181
-->

<p>
The <a href="https://golang.org/doc/faq#pass_by_value">official Go FAQ</a>
says <b><i>copying an interface value makes a copy of the thing stored in the interface value.</i></b>.
The article <a href="interface.html#boxing">interfaces in Go</a> mentions that,
for the standard Go compiler, the time complexity of copying an interface value
is <code><i>O</i>(1)</code>.
But the the sizes of different dynamic values stored in interface values may
be different, why isn't the complexity <code><i>O</i>(n)</code>?
</p>

<p>
The reason is the dynamic values of interface values are all inmutable,
so the standard Go compiler makes an optimization here.
As the article <a href="value-part.html#interface-structure">value parts</a>
has explained, an non-nil interface value has an underlying part and
the direct part of the interface value stores a pointer which
references the underlying part. When the interface value is copied,
only its direct part is copied. For the standard Go compiler,
the sizes of the direct parts of all interface values are the same.
</p>

<p class="anchor" id="constent-map-keys"></p>
<h3>Constant key values in a container composite literal can't be duplicated</h3>

<div>
Duplicated non-constant keys are allowed. For example:

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	const N = 123
	var n = N
	
	var m = map[int]string {
		N: "abc",
		// N: "xyz", // error: duplicate key N in map literal
		n: "hello", // ok
		n: "bye", // ok
	}
	
	fmt.Println(m[N])
}
</code></pre>

<p>
Please note, Go specification doesn't specifies the element initilization
order in a composite literal. So the above program may print <code>abc</code>,
<code>hello</code> or <code>bye</code>, depending on compilers and compiler versions.
</p>
</div>

<p class="anchor" id="addresses-of-zeor-sized-values"></p>
<h3>Addresses of different zero-sized value may be equal, or not</h3>
<!--
https://github.com/golang/go/issues/12726
-->

<div>
Whether or not the addresses of two zero-sized values are equal
is compiler and compiler version dependent.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := struct{}{}
	b := struct{}{}
	x := struct{}{}
	y := struct{}{}
	m := [10]struct{}{}
	n := [10]struct{}{}
	o := [10]struct{}{}
	p := [10]struct{}{}
	
	fmt.Println(&x, &y, &o, &p)
	
	// For the standard Go compiler (1.10),
	// x, y, o and p escape to heap,
	// but a, b, m and n are allocated on stack.
	
	fmt.Println(&a == &b) // false
	fmt.Println(&x == &y) // true
	fmt.Println(&a == &x) // false
	
	fmt.Println(&m == &n) // false
	fmt.Println(&o == &p) // true
	fmt.Println(&n == &p) // false
}
</code></pre>

<p>
The outputs indicated in the above code are for the standard Go compiler 1.10.
</p>
</div>

<p class="anchor" id="check-file-existent"></p>
<h3>We should not use <code>os.IsNotExist(err)</code> instead of <code>err == os.ErrNotExist</code> to check whether or not a file exists</h3>

<div>

Using <code>err == os.ErrNotExist</code> may miss errors.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"os"
)

func main() {
	_, err := os.Stat("a-nonexistent-file.abcxyz")
	fmt.Println(os.IsNotExist(err))    // true
	fmt.Println(err == os.ErrNotExist) // false
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="self-based-pointer-type"></p>
<h3>The base type of a pointer type may be the pointer type itself</h3>

<div>

An example:

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type P *P
	var p P
	p = &p
	p = **************p
}
</code></pre>

<p>
</p>

Similarly, 
<ul>
<li>
	the element type of a slice type can be the slice type itself,
</li>
<li>
	the element type of a map type can be the map type itself,
</li>
<li>
	the element type of a channel type can be the channel type itself,
</li>
<li>
	and the argument and result types of a function type can be the function type itself.
</li>
</ul>

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type S []S
	type M map[string]M
	type C chan C
	type F func(F) F
	
	s := S{0:nil}
	s[0] = s
	m := M{"Go": nil}
	m["Go"] = m
	c := make(C, 3)
	c <- c; c <- c; c <- c
	var f F
	f = func(F)F {return f}
	
	_ = s[0][0][0][0][0][0][0][0]
	_ = m["Go"]["Go"]["Go"]["Go"]
	<-<-<-c
	f(f(f(f(f))))
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="sometimes-parentheses-are-required"></p>
<h3>Parentheses are required in several rare scenarios to make code compile okay</h3>

<div>
For example:

<pre class="line-numbers"><code class="language-go">package main

type T struct{x, y int}

func main() {
	// Each of the following three lines makes code fail to compile.
	// Some "{}" confuse compilers.
	/*
	if T{} == T{123, 789} {}
	if T{} == (T{123, 789}) {}
	if (T{}) == T{123, 789} {}
	*/
	
	// We must add parentheses like the following two lines to
	// make code compile okay.
	if (T{} == T{123, 789}) {}
	if (T{}) == (T{123, 789}) {}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="force-import-path"></p>
<h3>The comment <code>// import "x.y.z.mypkg"</code> following <code>package mypkg</code> is meaningful for the standard Go compiler</h3>

<div>
For example, when the source files importing this package are compiled by the standard Go compiler,
the import path of the following package must be <code>"x.y.z.mypkg"</code>.

<pre class="line-numbers"><code class="language-go">package mypkg // import "x.y.z.mypkg"
...
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="different-loops"></p>
<h3>For a slice <code>s</code>, the loop <code>for i = range s {...}</code> is not equivalent to the loop <code>for i = 0; i < len(s); i++ {...}</code></h3>

<div>
The respective final values of the iteration variable <Code>i</code>
may be different for the two loops.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var i int

func fa(s []int, n int) int {
	i = n
	for i = 0; i < len(s); i++ {}
	return i
}

func fb(s []int, n int) int {
	i = n
	for i = range s {}
	return i
}

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(fa(s, -1), fb(s, -1)) // 6 5
	s = nil
	fmt.Println(fa(s, -1), fb(s, -1)) // 0 -1
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="main-entry-function-missing"></p>
<h3>A program doesn't need a <code>main</code> entry function to run</h3>

<div>
The following program runs well, at least for the standard Go compiler 1.10.
(It may be not runnable since 1.11. Please read <a href="https://github.com/golang/go/issues/21256">issue#21256</a> for details.)

<pre class="line-numbers"><code class="language-go">package main

import (
    "fmt"
    "time"
)

func init() {
	for {
		time.Sleep(time.Second)
		fmt.Println("hi")
	}
}

var main int
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="pointer-selector-shorthands"></p>
<h3>A detail about selector shorthands</h3>

<div>

<p>
<p>
A pointer value, either its type is defined or not,
of a defined one-level struct pointer type
can access the <b>fields</b> of the struct value it references,
But two-level (and higher level) pointers,
either its type is defined or not, can't.
</p>

<p>
But, only the non-defined pointer values can access the <b>methods</b>
of the respective non-pointer and non-interface values they reference.
</p>

<pre class="line-numbers"><code class="language-go">package main

type T struct {
	x int
}
func (T) m(){} // T has one method.

type P *T  // a defined one-level pointer type.
type PP *P // a defined two-level pointer type.

func main() {
	var t T
	var tp = &t
	var tpp = &tp
	var p P = tp
	var pp PP = &p
	tp.x = 12  // okay
	p.x = 34   // okay
	pp.x = 56  // error: type PP has no field or method x
	tpp.x = 78 // error: type **T has no field or method x)
	
	tp.m()  // okay
	p.m()   // error: type P has no field or method m
	pp.m()  // error: type PP has no field or method m
	tpp.m() // error: type **T has no field or method m
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="errors-new-different-returns"></p>
<h3>Two <code>error</code> values returned by two <code>errors.New</code> with the same argument are not equal</h3>

<div>
The reason is the <code>errors.New</code> function will copy the input string argument
and use a pointer to the copied string as the dynamic value of the returned <code>error</code> value.
Two different calls will produce two different pointers.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "errors"

func main() {
	notfound := "not found"
	a, b := errors.New(notfound), errors.New(notfound)
	fmt.Println(a == b) // false
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="boolean-flag"></p>
<h3>The <code>flag</code> standard package treats boolean command flags differently than integer and string flags</h3>

<div>
There are three forms to pass command arguments.
<ol>
<li>
	<code>-flag</code>, for boolean flags only.
</li>
<li>
	<code>-flag=x</code>, for any flag.
</li>
<li>
	<code>-flag x</code>, for non-boolean flags only.
</li>
</ol>

<p>
And please note that, all items following a boolean flag with
the first form are viewed as arguments.
</p>

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "flag"

var b = flag.Bool("b", true, "a boolean flag")
var i = flag.Int("i", 123, "an integer flag")
var s = flag.String("s", "hi", "a string flag")

func main() {
	flag.Parse()
	fmt.Print("b=", *b, ", i=", *i, ", s=", *s, "\n")
	fmt.Println("arguments:", flag.Args())
}
</code></pre>

<p>
</p>

If we run the following program with the below shown flags and arguments

<pre class="output"><code>./exampleProgram -b false -i 789 -s bye arg0 arg1
</code></pre>

the output will be

<pre class="output"><code>b=true, i=123, s=hi
arguments: [false -i 789 -s bye arg0 arg1]
</code></pre>

<p>
This output is obviously not what we expect.
</p>

We should pass the flags and arguments like

<pre class="output"><code>./exampleProgram -b=false -i 789 -s bye arg0 arg1
</code></pre>

or

<pre class="output"><code>./exampleProgram -i 789 -s bye -b arg0 arg1
</code></pre>

to get the output we expect:

<pre class="output"><code>b=true, i=789, s=bye
arguments: [arg0 arg1]
</code></pre>

</div>

<p class="anchor" id="capacity-of-slice-from-string"></p>
<h3>The capacity of the result slice of a conversion from a string to byte/rune slice may be larger than the length of the result slice</h3>

<div>
<p>
We should not assume the length and the capacity of the result slice are alway equal.
</p>

In the following example, if the last <code>fmt.Println</code> line is removed,
the outputs of the two lines before it print the same value <code>32</code>,
otherwise, one print <code>32</code> and one print <code>8</code>.
(For the standard Go compiler 1.10.)

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	s := "a"
	x := []byte(s)              // len(s) == 1
	fmt.Println(cap([]byte(s))) // 32
	fmt.Println(cap(x))         // 8
	fmt.Println(x)
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="printf-positional-arguments"></p>
<h3><code>[Sp|Fp|P]rintf</code> functions support positional arguments</h3>

<div>
<p>
The following program will print <code>3, 2, 1</code>.
</p>

An example:

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	fmt.Printf("%[3]v, %[2]v, %[1]v", 1, 2, 3) // 3, 2, 1
}
</code></pre>

<p>
</p>
</div>





<!---
https://github.com/golang/go/issues/13890

https://github.com/golang/go/issues/24693

https://github.com/golang/go/issues/24721

Try not to use multi-value assignments.
Reason 1: maybe bug. Reason 3: unspecified behaviours. 2: maybe inefficient.
https://github.com/golang/go/issues/23188#issuecomment-361482955
https://github.com/golang/go/issues/23017
https://github.com/golang/go/issues/22881
https://github.com/golang/go/issues/24448

-->








